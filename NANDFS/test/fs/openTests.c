/*************************************************
 * Copyright (C) 2009 Aviad Zuck & Sivan Toledo
 * This file is part of NANDFS.
 *
 * To license NANDFS under a different license, please
 * contact the authors.
 *
 * NANDFS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * NANDFS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * You should have received a copy of the GNU Lesser General Public License
 * along with NANDFS.  If not, see <http://www.gnu.org/licenses/>.
 */

/** @file openTests.c  */
#include <test/fs/openTests.h>
#include <test/fs/testsHeader.h>

void runAllOpenTests(){

	RUN_TEST(open,1);
	RUN_TEST(open,2);
	RUN_TEST(open,3);
	RUN_TEST(open,4);
	RUN_TEST(open,5);
	RUN_TEST(open,6);
	RUN_TEST(open,7);
	RUN_TEST(open,8);
	RUN_TEST(open,9);

	RUN_TEST(open,23);
	RUN_TEST(open,24);
	RUN_TEST(open,25);
	RUN_TEST(open,26);

}

/**
 * @brief
 * init open test
 *
 */
void init_openTest(){
	if(nandInit())
		return;
//	PRINT("\nstart init_openTest()");
	init_flash();
	init_file_entries();
	init_vnodes();
	init_transactions();
	initializeRamStructs();
	handleNoFs();
	init_fsbuf(fs_buffer);
//	PRINT("\nfinished init_openTest()");
	//	bool_t pendingVOTs;
//	/* boot sequencing layer */
//	VERIFY(!sequencingBooting(fs_ptr, sizeof(filesystem_t), &pendingVOTs, checkpointWriter));
}

/**
 * @brief
 * tear down open test
 *
 */
void tearDown_openTest(){
	init_flash();
	init_file_entries();
	init_vnodes();
	init_transactions();

	nandTerminate();
	init_fsbuf(fs_buffer);
	initializeRamStructs();
}

/**
 * @brief
 * open a file that already exists for reading.
 * should succeed
 * @return 1 if successful, 0 otherwise
 */
error_t openTest1(){
	uint32_t i, flags = NANDFS_O_RDONLY;
	int32_t fd;
	user_id user = 1;

//	PRINT("\nopen1 start");

	/* set user in process*/
	SET_CURRENT_USER(user);
	fd = open(VALID_MOCK_FILE_NAME_1, flags, 0);

	VERIFY(!IS_FD_ERROR(fd));
//	PRINT("\nopen success");

	/* verify file entry fields*/
	VERIFY(verifyOpenFileEntry(fd,flags,0,user,0));
//	PRINT("\nverified open file entry #0");
	VERIFY(verifyVnode(OPEN_FILE_GET_VNODE(fd), VALID_MOCK_INO_NUM_1, 1));
//	PRINT("\nverified vnode");

	/* verify all other file entries are empty*/
	for(i=0;i< FS_MAX_OPEN_FILES;i++){
		if(i==fd)
			continue;

		VERIFY(verifyOpenFileEntryEmpty(i));
	}
//	PRINT("\nverified open file entries");
	/* verify all other vnodes are empty */
	for(i=0;i< FS_MAX_VNODES;i++){
		if(i==OPEN_FILE_GET_VNODE(fd))
			continue;

		VERIFY(verifyVnodeEmpty(i));
	}

	return 1;
}

/**
 * @brief
 * open a file that doesn't exists for reading.
 * should fail
 * @return 1 if successful, 0 otherwise
 */
error_t openTest2(){
	user_id user = 1;
	uint32_t i, flags = NANDFS_O_RDONLY;
	int32_t fd;

	/* set user in process*/
	SET_CURRENT_USER(user);
	fd = open(INVALID_MOCK_FILE_NAME_1, flags, 0);

//	PRINT_MSG_AND_NUM("\nfd=",fd);
	VERIFY(COMPARE(fd,FD_EMPTY));
//	PRINT("\nfd success");
	/* verify all file entries are empty*/
	for(i=0;i< FS_MAX_OPEN_FILES;i++){
		VERIFY(verifyOpenFileEntryEmpty(i));
	}

	/* verify all other vnodes are empty */
	for(i=0;i< FS_MAX_VNODES;i++){
		VERIFY(verifyVnodeEmpty(i));
	}

	return 1;
}

/**
 * @brief
 * open a file that exists for writing.
 * should succeed
 * @return 1 if successful, 0 otherwise
 */
error_t openTest3(){
	user_id user = 1;
	uint32_t i, flags = NANDFS_O_WRONLY;
	int32_t fd;

	/* set user in process*/
	SET_CURRENT_USER(user);
	fd = open(VALID_MOCK_FILE_NAME_1, flags, 0);

	VERIFY(!COMPARE(fd,-1));

	/* verify file entry fields*/
	VERIFY(verifyOpenFileEntry(fd,flags,0,user,0));
	VERIFY(verifyVnode(OPEN_FILE_GET_VNODE(fd), VALID_MOCK_INO_NUM_1, 1));

	/* verify all other file entries are empty*/
	for(i=0;i< FS_MAX_OPEN_FILES;i++){
		if(i==fd)
			continue;

		VERIFY(verifyOpenFileEntryEmpty(i));
	}

	/* verify all other vnodes are empty */
	for(i=0;i< FS_MAX_VNODES;i++){
		if(i==OPEN_FILE_GET_VNODE(fd))
			continue;

		VERIFY(verifyVnodeEmpty(i));
	}

	return 1;
}

/**
 * @brief
 * open a file that doesn't exists for writing
 * should fail
 * @return 1 if successful, 0 otherwise
 */
error_t openTest4(){
	user_id user = 1;
	uint32_t i, flags = NANDFS_O_WRONLY;
	int32_t fd;

	/* set user in process*/
	SET_CURRENT_USER(user);
	fd = open(INVALID_MOCK_FILE_NAME_1, flags, 0);

	VERIFY(IS_NEGATIVE(fd));

	/* verify all file entries are empty*/
	for(i=0;i< FS_MAX_OPEN_FILES;i++){
		VERIFY(verifyOpenFileEntryEmpty(i));
	}

	/* verify all other vnodes are empty */
	for(i=0;i< FS_MAX_VNODES;i++){
		VERIFY(verifyVnodeEmpty(i));
	}

	return 1;
}
/**
 * @brief
 * open a file that exists twice for reading
 * should succeed
 * @return 1 if successful, 0 otherwise
 */
error_t openTest5(){
	user_id user1 = 1, user2 = 2;
	uint32_t i, flags = NANDFS_O_RDONLY;
	int32_t fd1, fd2;

	/* set user1 in process*/
	SET_CURRENT_USER(user1);
	fd1 = open(VALID_MOCK_FILE_NAME_1, flags, 0);

	/* verify open */
	VERIFY(!IS_NEGATIVE(fd1));
	VERIFY(verifyOpenFileEntry(fd1,flags,0,user1,0));
	VERIFY(verifyVnode(OPEN_FILE_GET_VNODE(fd1), VALID_MOCK_INO_NUM_1, 1));

	/* set user2 in process*/
	SET_CURRENT_USER(user2);
	fd2 = open(VALID_MOCK_FILE_NAME_1, flags, 0);

	/* verify open*/
	VERIFY(!IS_NEGATIVE(fd2));
	VERIFY(verifyOpenFileEntry(fd2,flags,0,user2,0));
	VERIFY(verifyVnode(OPEN_FILE_GET_VNODE(fd2), VALID_MOCK_INO_NUM_1, 2));

	/* verify all other file entries are empty*/
	for(i=0;i< FS_MAX_OPEN_FILES;i++){
		if(i==fd1 || i == fd2)
			continue;

		VERIFY(verifyOpenFileEntryEmpty(i));
	}

	/* verify all other vnodes are empty */
	for(i=0;i< FS_MAX_VNODES;i++){
		if(i==OPEN_FILE_GET_VNODE(fd1) || i==OPEN_FILE_GET_VNODE(fd2))
			continue;

		VERIFY(verifyVnodeEmpty(i));
	}

	return 1;
}
/**
 * @brief
 * open a file for writing, then try to open it to reading by another user
 * should fail
 * @return 1 if successful, 0 otherwise
 */
error_t openTest6(){
	user_id user1 = 1, user2 = 2;
	uint32_t i, flags1 = NANDFS_O_WRONLY, flags2 = NANDFS_O_RDONLY;
	int32_t fd1, fd2;

	/* set user1 in process*/
	SET_CURRENT_USER(user1);
	fd1 = open(VALID_MOCK_FILE_NAME_1, flags1, 0);

	/* verify open for writing */
	VERIFY(!COMPARE(fd1,-1));
	VERIFY(verifyOpenFileEntry(fd1,flags1,0,user1,0));
	VERIFY(verifyVnode(OPEN_FILE_GET_VNODE(fd1), VALID_MOCK_INO_NUM_1, 1));

	/* set user2 in process*/
	SET_CURRENT_USER(user2);
	fd2 = open(VALID_MOCK_FILE_NAME_1, flags2, 0);

	/* verify not open for reading */
	VERIFY(COMPARE(fd2,-1));

	/* verify all other file entries are empty*/
	for(i=0;i< FS_MAX_OPEN_FILES;i++){
		if(i==fd1)
			continue;

		VERIFY(verifyOpenFileEntryEmpty(i));
	}

	/* verify all other vnodes are empty */
	for(i=0;i< FS_MAX_VNODES;i++){
		if(i==OPEN_FILE_GET_VNODE(fd1))
			continue;

		VERIFY(verifyVnodeEmpty(i));
	}

	return 1;
}

/**
 * @brief
 * open a file that exists for reading, the try to  open for writing by another user.
 * should fail (write exclusive)
 * @return 1 if successful, 0 otherwise
 */
error_t openTest7(){
	user_id user1 = 1, user2 = 2;
	uint32_t i, flags1 = NANDFS_O_RDONLY, flags2 = NANDFS_O_WRONLY;
	int32_t fd1, fd2;

	/* set user1 in process*/
	SET_CURRENT_USER(user1);
	fd1 = open(VALID_MOCK_FILE_NAME_1, flags1, 0);

	/* verify open for reading */
	VERIFY(!COMPARE(fd1,-1));
	VERIFY(verifyOpenFileEntry(fd1,flags1,0,user1,0));
	VERIFY(verifyVnode(OPEN_FILE_GET_VNODE(fd1), VALID_MOCK_INO_NUM_1, 1));

	/* set user2 in process*/
	SET_CURRENT_USER(user2);
	fd2 = open(VALID_MOCK_FILE_NAME_1, flags2, 0);

	/* verify not open for reading */
	VERIFY(COMPARE(fd2,-1));

	/* verify all other file entries are empty*/
	for(i=0;i< FS_MAX_OPEN_FILES;i++){
		if(i==fd1)
			continue;

		VERIFY(verifyOpenFileEntryEmpty(i));
	}

	/* verify all other vnodes are empty */
	for(i=0;i< FS_MAX_VNODES;i++){
		if(i==OPEN_FILE_GET_VNODE(fd1))
			continue;

		VERIFY(verifyVnodeEmpty(i));
	}

	return 1;
}

/**
 * @brief
 * open FS_MAX_VNODES different files for reading , then another file and make sure
 * the last open fails with the matching error
 * @return 1 if successful, 0 otherwise
 */
error_t openTest8(){
	user_id user = 1;
	uint32_t i, flags = NANDFS_O_RDONLY;
	int32_t fd;

	/* fill all vnodes */
	for(i=0; i<FS_MAX_VNODES;i++){
		VNODE_SET_INO_NUM(i, i);
		VNODE_SET_NREFS(i, i);
	}

	/* set user in process*/
	SET_CURRENT_USER(user);
	fd = open(VALID_MOCK_FILE_NAME_1, flags, 0);
	VERIFY(COMPARE(fd,FD_EMPTY));

	return 1;
}

/**
 * @brief
 * open with different users FS_MAX_OPEN_FILES open file entries (for less than FS_MAX_VNODES files),
 * than another file and making sure  the last open fails with
 * the matching error
 * @return 1 if successful, 0 otherwise
 */
error_t openTest9(){
	user_id user1 = 1, user2 = 2;
	uint32_t i, flags1 = NANDFS_O_RDONLY, flags2 = NANDFS_O_RDONLY;
	int32_t fd1, fd2;

	/* set user1 in process*/
	SET_CURRENT_USER(user1);
	fd1 = open(VALID_MOCK_FILE_NAME_1, flags1, 0);
//	PRINT_MSG_AND_NUM("\nfd1=", fd1);
	/* verify open for reading */
	VERIFY(!COMPARE(fd1,FD_EMPTY));
	VERIFY(verifyOpenFileEntry(fd1,flags1,0,user1,0));
	VERIFY(verifyVnode(OPEN_FILE_GET_VNODE(fd1), VALID_MOCK_INO_NUM_1, 1));

	/* set user2 in process*/
	SET_CURRENT_USER(user2);

	for(i=1;i<FS_MAX_OPEN_FILES;i++){
		fd2 = open(VALID_MOCK_FILE_NAME_2, flags2, 0);
//		PRINT_MSG_AND_NUM("\nfd2=", fd2);
		/* verify open for reading */
		VERIFY(!IS_NEGATIVE(fd2));
		VERIFY(verifyOpenFileEntry(fd2,flags2,0,user2,1));
	}

	/* verify all other file entries are empty*/
	for(i=0;i< FS_MAX_OPEN_FILES;i++){
		VERIFY(!verifyOpenFileEntryEmpty(i));
	}

	/* verify all other vnodes are empty */
	for(i=2;i< FS_MAX_VNODES;i++){
		VERIFY(verifyVnodeEmpty(i));
	}

	/* now try opening again and verify failure */
	fd2 = open(VALID_MOCK_FILE_NAME_2, flags2, 0);
//	PRINT_MSG_AND_NUM("\nfd2=", fd2);
	VERIFY(IS_NEGATIVE(fd2));

	return 1;
}

///************* test to check after we have read, write etc.***********/
///**
// * @brief
// * open a file that exists with O_TRUNCAT and verify it was indeed truncated
// * @return 1 if successful, 0 otherwise
// */
//error_t openTest20(){
//	return 1;
//}
//
///**
// * @brief
// * open a file for writing with O_APPEND and making sure that
// * the file entry offset is set to the end of the file
// * should fail
// * @return 1 if successful, 0 otherwise
// */
//error_t openTest22(){
//	return 1;
//}

/**
 * @brief
 * try opening a pathname that leads to a directory with write permission.
 * should fail
 * @return 1 if successful, 0 otherwise
 */
error_t openTest23(){
	int32_t res;

	/* try opening root directory for reading and verify success*/
	res = open("/", NANDFS_O_RDONLY, 0);
	VERIFY(!res);

	/* try opening root directory for writing and verify failure*/
	res = open("/", NANDFS_O_WRONLY, 0);
	VERIFY(IS_NEGATIVE(res));

	return 1;
}

/**
 * @brief
 * try opening a pathname which has a non existing directory in the middle
 * should fail
 * @return 1 if successful, 0 otherwise
 */
error_t openTest24(){
	bool_t cpWritten;
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(prev_log_addr);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_file);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_dir2);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_dir1);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_root);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr);
	dirent_flash *dirent_ptr = CAST_TO_DIRENT(fs_buffer);
	inode_t *ino_ptr = CAST_TO_INODE(fs_buffer);
	uint8_t *f_full_name = "/directory1/directory2/directory3/file1_nonexistent.dat";
	uint32_t i;
	int32_t fd;
	user_id user = 1;

	init_logical_address(prev_log_addr);
	init_logical_address(log_addr_file);
	init_logical_address(log_addr_dir2);
	init_logical_address(log_addr_dir1);
	init_logical_address(log_addr_root);
	init_logical_address(log_addr);

	/* set user in process*/
	SET_CURRENT_USER(user);

	/* write file inode */
	VERIFY(!writeNewInode(4, INO_NUM_EMPTY, FTYPE_FILE, log_addr_file));
//	PRINT("\nwriteNewInode 4 success");

	/* write directory2 inode*/
	VERIFY(!writeNewInode(3, 2, FTYPE_DIR, log_addr_dir2));
//	PRINT("\nwriteNewInode 3 success");

	/* write directory1 inode*/
	VERIFY(!writeNewInode(2, 1, FTYPE_DIR, log_addr_dir1));
//	PRINT("\nwriteNewInode 2 success");

	/* write file1.dat direntry in directory2*/
	VERIFY(!readFileBlock(fs_buffer, 3, INODE_FILE_DATA_SIZE, log_addr_dir2, TID_EMPTY));

//	PRINT("\nreadFileBlock success");
	/* iterate until we find an empty directory entry*/
	while(!IS_DIRENT_EMPTY(dirent_ptr)){
		moveToNextDirentry(&dirent_ptr, DIRENT_GET_LEN(dirent_ptr));
	}
//	PRINT("\nmoveToNextDirentry success");

	setNewDirentry(dirent_ptr, 4, FTYPE_FILE, "file1.dat");
//	PRINT("\nsetNewDirentry success");

	VERIFY(!allocAndWriteBlock(log_addr, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));
//	PRINT("\nallocAndWriteBlock 4 success");

	/* write directory2 inode with new pointer to the above block*/
	VERIFY(!fsReadBlockSimple(log_addr_dir2, fs_buffer));
	INODE_SET_DIRECT(ino_ptr,0,log_addr);

	VERIFY(!allocAndWriteBlock(log_addr_dir2, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));
//	PRINT("\nallocAndWriteBlock directory2 inode success");

	/* write directory2 direntry in directory1*/
	VERIFY(!readFileBlock(fs_buffer, 2, INODE_FILE_DATA_SIZE, log_addr_dir1, -1));

	/* iterate until we find an empty directory entry*/
	while(!IS_DIRENT_EMPTY(dirent_ptr))
		moveToNextDirentry(&dirent_ptr, DIRENT_GET_LEN(dirent_ptr));

	setNewDirentry(dirent_ptr, 3, FTYPE_DIR, "directory2");
	VERIFY(!allocAndWriteBlock(log_addr, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));
//	PRINT("\nallocAndWriteBlock 3 success");

	/* write directory1 inode with new pointer to the above block*/
	VERIFY(!fsReadBlockSimple(log_addr_dir1, fs_buffer));
	INODE_SET_DIRECT(ino_ptr,0,log_addr);
	VERIFY(!allocAndWriteBlock(log_addr_dir1, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory1 direntry in root*/
	VERIFY(!readFileBlock(fs_buffer, 1, INODE_FILE_DATA_SIZE, log_addr_root, TID_EMPTY));

	/* iterate until we find an empty directory entry*/
	while(!IS_DIRENT_EMPTY(dirent_ptr))
		moveToNextDirentry(&dirent_ptr, DIRENT_GET_LEN(dirent_ptr));

	setNewDirentry(dirent_ptr, 2, FTYPE_DIR, "directory1");
	VERIFY(!allocAndWriteBlock(log_addr, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));
//	PRINT("\nallocAndWriteBlock 2 success");

	/* write directory1 inode with new pointer to the above block*/
	VERIFY(!fsReadBlockSimple(log_addr_root, fs_buffer));
	INODE_SET_DIRECT(ino_ptr,0,log_addr);
	VERIFY(!allocAndWriteBlock(log_addr_root, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write inode0 with pointers to the new root address*/
	VERIFY(!fsReadBlockSimple(FS_GET_INO0_ADDR_PTR(), fs_buffer));

	INODE_SET_DIRECT(ino_ptr,0,log_addr_root);
	INODE_SET_DIRECT(ino_ptr,1,log_addr_dir1);
	INODE_SET_DIRECT(ino_ptr,2,log_addr_dir2);
	INODE_SET_DIRECT(ino_ptr,3,log_addr_file);
	INODE_SET_NBYTES(ino_ptr, CAST_VAL_TO_UINT32(INODE_FILE_DATA_SIZE+4*FS_BLOCK_SIZE));
	VERIFY(!allocAndWriteBlock(FS_GET_INO0_ADDR_PTR(), fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

//	PRINT("\nabout to open");
	/* and now try opening file1.dat*/
	fd = open(f_full_name, NANDFS_O_RDONLY, 0);
	VERIFY(IS_NEGATIVE(fd));

	for(i=0; i< FS_MAX_OPEN_FILES;i++){
		VERIFY(verifyOpenFileEntryEmpty(i));
	}

	for(i=0; i<FS_MAX_VNODES;i++){
		VERIFY(verifyVnodeEmpty(i));
	}
//	verifyOpenFileEntry(fd2,flags,0,user2,0);

	return 1;
}

/**
 * @brief
 * try opening a pathname which has a non existing directory in the end
 * should fail
 * @return 1 if successful, 0 otherwise
 */
error_t openTest25(){
	bool_t cpWritten;
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(prev_log_addr);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_file);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_dir2);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_dir1);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_root);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr);
	dirent_flash *dirent_ptr = CAST_TO_DIRENT(fs_buffer);
	inode_t *ino_ptr = CAST_TO_INODE(fs_buffer);
	uint8_t *f_full_name = "/directory1/directory2/directory3/";
	uint32_t i;
	int32_t fd;
	user_id user = 1;

	init_logical_address(prev_log_addr);
	init_logical_address(log_addr_file);
	init_logical_address(log_addr_dir2);
	init_logical_address(log_addr_dir1);
	init_logical_address(log_addr_root);
	init_logical_address(log_addr);

	/* set user in process*/
	SET_CURRENT_USER(user);

	/* write file inode */
	VERIFY(!writeNewInode(4, INO_NUM_EMPTY, FTYPE_FILE, log_addr_file));

	/* write directory2 inode*/
	VERIFY(!writeNewInode(3, 2, FTYPE_DIR, log_addr_dir2));

	/* write directory1 inode*/
	VERIFY(!writeNewInode(2, 1, FTYPE_DIR, log_addr_dir1));


	/* write file1.dat direntry in directory2*/
	VERIFY(!readFileBlock(fs_buffer, 3, INODE_FILE_DATA_SIZE, log_addr_dir2, TID_EMPTY));

	/* iterate until we find an empty directory entry*/
	while(!IS_DIRENT_EMPTY(dirent_ptr))
		moveToNextDirentry(&dirent_ptr, DIRENT_GET_LEN(dirent_ptr));

	setNewDirentry(dirent_ptr, 4, FTYPE_FILE, "file1.dat");
	VERIFY(!allocAndWriteBlock(log_addr, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory2 inode with new pointer to the above block*/
	VERIFY(!fsReadBlockSimple(log_addr_dir2, fs_buffer));
	INODE_SET_DIRECT(ino_ptr,0,log_addr);
	VERIFY(!allocAndWriteBlock(log_addr_dir2, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory2 direntry in directory1*/
	VERIFY(!readFileBlock(fs_buffer, 2, INODE_FILE_DATA_SIZE, log_addr_dir1, TID_EMPTY));

	/* iterate until we find an empty directory entry*/
	while(!IS_DIRENT_EMPTY(dirent_ptr))
		moveToNextDirentry(&dirent_ptr, DIRENT_GET_LEN(dirent_ptr));

	setNewDirentry(dirent_ptr, 3, FTYPE_DIR, "directory2");
	VERIFY(!allocAndWriteBlock(log_addr, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory1 inode with new pointer to the above block*/
	VERIFY(!fsReadBlockSimple(log_addr_dir1, fs_buffer));
	INODE_SET_DIRECT(ino_ptr,0,log_addr);
	VERIFY(!allocAndWriteBlock(log_addr_dir1, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory1 direntry in root*/
	VERIFY(!readFileBlock(fs_buffer, 1, INODE_FILE_DATA_SIZE, log_addr_root, TID_EMPTY));

	/* iterate until we find an empty directory entry*/
	while(!IS_DIRENT_EMPTY(dirent_ptr))
		moveToNextDirentry(&dirent_ptr, DIRENT_GET_LEN(dirent_ptr));

	setNewDirentry(dirent_ptr, 2, FTYPE_DIR, "directory1");
	VERIFY(!allocAndWriteBlock(log_addr, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory1 inode with new pointer to the above block*/
	VERIFY(!fsReadBlockSimple(log_addr_root, fs_buffer));
	INODE_SET_DIRECT(ino_ptr,0,log_addr);
	VERIFY(!allocAndWriteBlock(log_addr_root, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write inode0 with pointers to the new root address*/
	VERIFY(!fsReadBlockSimple(FS_GET_INO0_ADDR_PTR(), fs_buffer));

	INODE_SET_DIRECT(ino_ptr,0,log_addr_root);
	INODE_SET_DIRECT(ino_ptr,1,log_addr_dir1);
	INODE_SET_DIRECT(ino_ptr,2,log_addr_dir2);
	INODE_SET_DIRECT(ino_ptr,3,log_addr_file);
	INODE_SET_NBYTES(ino_ptr, CAST_VAL_TO_UINT32(INODE_FILE_DATA_SIZE+4*FS_BLOCK_SIZE));
	VERIFY(!allocAndWriteBlock(FS_GET_INO0_ADDR_PTR(), fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* and now try opening file1.dat*/
	fd = open(f_full_name, NANDFS_O_RDONLY, 0);
	VERIFY(IS_NEGATIVE(fd));

	for(i=0; i< FS_MAX_OPEN_FILES;i++){
		VERIFY(verifyOpenFileEntryEmpty(i));
	}

	for(i=0; i<FS_MAX_VNODES;i++)
		VERIFY(verifyVnodeEmpty(i));

	return 1;
}

/**
 * @brief
 * try opening a legal pathname with "." and ".."
 * @return 1 if successful, 0 otherwise
 */
error_t openTest26(){
	bool_t cpWritten;
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(prev_log_addr);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_file);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_dir2);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_dir1);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr_root);
	INIT_LOGICAL_ADDRESS_STRUCT_AND_PTR(log_addr);
	dirent_flash *dirent_ptr = CAST_TO_DIRENT(fs_buffer);
	inode_t *ino_ptr = CAST_TO_INODE(fs_buffer);
	uint8_t *f_full_name = "/directory1/../directory1/directory2/file1.dat";
	uint32_t i;
	int32_t fd, flags = NANDFS_O_RDONLY;
	user_id user = 1;

	init_logical_address(prev_log_addr);
	init_logical_address(log_addr_file);
	init_logical_address(log_addr_dir2);
	init_logical_address(log_addr_dir1);
	init_logical_address(log_addr_root);
	init_logical_address(log_addr);

	/* set user in process*/
	SET_CURRENT_USER(user);

	/* write file inode */
	VERIFY(!writeNewInode(4, INO_NUM_EMPTY, FTYPE_FILE, log_addr_file));

	/* write directory2 inode*/
	VERIFY(!writeNewInode(3, 2, FTYPE_DIR, log_addr_dir2));

	/* write directory1 inode*/
	VERIFY(!writeNewInode(2, 1, FTYPE_DIR, log_addr_dir1));

	/* write file1.dat direntry in directory2*/
	VERIFY(!readFileBlock(fs_buffer, 3, INODE_FILE_DATA_SIZE, log_addr_dir2, TID_EMPTY));

	/* iterate until we find an empty directory entry*/
	while(!IS_DIRENT_EMPTY(dirent_ptr))
		moveToNextDirentry(&dirent_ptr, DIRENT_GET_LEN(dirent_ptr));

	setNewDirentry(dirent_ptr, 4, FTYPE_FILE, "file1.dat");
	VERIFY(!allocAndWriteBlock(log_addr, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory2 inode with new pointer to the above block*/
	VERIFY(!fsReadBlockSimple(log_addr_dir2, fs_buffer));
	INODE_SET_DIRECT(ino_ptr,0,log_addr);

	VERIFY(!allocAndWriteBlock(log_addr_dir2, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory2 direntry in directory1*/
	VERIFY(!readFileBlock(fs_buffer, 2, INODE_FILE_DATA_SIZE, log_addr_dir1,TID_EMPTY));

	/* iterate until we find an empty directory entry*/
	while(!IS_DIRENT_EMPTY(dirent_ptr))
		moveToNextDirentry(&dirent_ptr, DIRENT_GET_LEN(dirent_ptr));

	setNewDirentry(dirent_ptr, 3, FTYPE_DIR, "directory2");
	VERIFY(!allocAndWriteBlock(log_addr, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory1 inode with new pointer to the above block*/
	VERIFY(!fsReadBlockSimple(log_addr_dir1, fs_buffer));
	INODE_SET_DIRECT(ino_ptr,0,log_addr);

	VERIFY(!allocAndWriteBlock(log_addr_dir1, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory1 direntry in root*/
	VERIFY(!readFileBlock(fs_buffer, 1, INODE_FILE_DATA_SIZE, log_addr_root, TID_EMPTY));

	/* iterate until we find an empty directory entry*/
	while(!IS_DIRENT_EMPTY(dirent_ptr))
		moveToNextDirentry(&dirent_ptr, DIRENT_GET_LEN(dirent_ptr));

	setNewDirentry(dirent_ptr, 2, FTYPE_DIR, "directory1");
	VERIFY(!allocAndWriteBlock(log_addr, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write directory1 inode with new pointer to the above block*/
	VERIFY(!fsReadBlockSimple(log_addr_root, fs_buffer));
	INODE_SET_DIRECT(ino_ptr,0,log_addr);
	VERIFY(!allocAndWriteBlock(log_addr_root, fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* write inode0 with pointers to the new root address*/
	VERIFY(!fsReadBlockSimple(FS_GET_INO0_ADDR_PTR(), fs_buffer));

	INODE_SET_DIRECT(ino_ptr,0,log_addr_root);
	INODE_SET_DIRECT(ino_ptr,1,log_addr_dir1);
	INODE_SET_DIRECT(ino_ptr,2,log_addr_dir2);
	INODE_SET_DIRECT(ino_ptr,3,log_addr_file);
	INODE_SET_NBYTES(ino_ptr, CAST_VAL_TO_UINT32(INODE_FILE_DATA_SIZE+4*FS_BLOCK_SIZE));
	VERIFY(!allocAndWriteBlock(FS_GET_INO0_ADDR_PTR(), fs_buffer, 0, prev_log_addr, &cpWritten, fsCheckpointWriter, 0));

	/* and now try opening file1.dat*/
	fd = open(f_full_name, flags, 0);

	VERIFY(!IS_NEGATIVE(fd));
	VERIFY(COMPARE(VNODE_GET_INO_NUM(OPEN_FILE_GET_VNODE(fd)), 4));
	VERIFY(IS_RDONLY(OPEN_FILE_GET_FLAGS(fd)));

	for(i=0; i< FS_MAX_OPEN_FILES;i++){
		if(i==fd){
			VERIFY(verifyOpenFileEntry(fd, flags,0,user, 0));
		}
		else{
			VERIFY(verifyOpenFileEntryEmpty(i));
		}
	}

	for(i=0; i<FS_MAX_VNODES;i++){
		if(i!=fd){
			VERIFY(verifyVnodeEmpty(i));
		}
		else{
			VERIFY(verifyVnode(i, 4, 1));
		}
	}
//

	return 1;
}
